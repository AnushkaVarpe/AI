STDIN: 4 A 0 B 4 C 5 D 10 2 2 B C 1 D 0 0 0

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdbool.h>

#define MAX_NODES 20
#define MAX_CHILDREN 5
#define MAX_GROUPS 5

typedef struct Node {
    char name;
    int cost;
    int heuristic;
    int numGroups;
    int groupSizes[MAX_GROUPS];
    struct Node *children[MAX_GROUPS][MAX_CHILDREN];
    struct Node *bestPath[MAX_CHILDREN];
    int bestPathSize;
} Node;

Node nodes[MAX_NODES];
int nodeCount = 0;

int findNodeIndex(char name) {
    for (int i = 0; i < nodeCount; i++) {
        if (nodes[i].name == name)
            return i;
    }
    return -1;
}

void ao(Node *node, int solvedCost[], bool solved[]) {
    if (node == NULL)
        return;
    int idx = node - nodes;
    if (solved[idx])
        return;
    if (node->numGroups == 0) { 
        solved[idx] = true;
        solvedCost[idx] = node->heuristic;
        node->cost = node->heuristic;
        return;
    }

    int minCost = INT_MAX;
    int bestGroupIndex = -1;

    for (int g = 0; g < node->numGroups; g++) {
        int groupCost = 0;
        for (int c = 0; c < node->groupSizes[g]; c++) {
            Node *child = node->children[g][c];
            int childIdx = child - nodes;
            if (!solved[childIdx])
                ao(child, solvedCost, solved);
            groupCost += solvedCost[childIdx];
        }
        if (groupCost < minCost) {
            minCost = groupCost;
            bestGroupIndex = g;
        }
    }

    node->cost = minCost;
    node->bestPathSize = node->groupSizes[bestGroupIndex];
    for (int i = 0; i < node->bestPathSize; i++) {
        node->bestPath[i] = node->children[bestGroupIndex][i];
    }
    solved[idx] = true;
    solvedCost[idx] = minCost;
}

void printSolution(Node *node, int solvedCost[], int depth) {
    if (node == NULL)
        return;
    int idx = node - nodes;

    for (int i = 0; i < depth; i++)
        printf("  ");
    printf("%c (Cost: %d)\n", node->name, solvedCost[idx]);

    for (int i = 0; i < node->bestPathSize; i++) {
        printSolution(node->bestPath[i], solvedCost, depth + 1);
    }
}

int main() {
    printf("Enter number of nodes (max %d): ", MAX_NODES);
    scanf("%d", &nodeCount);

    for (int i = 0; i < nodeCount; i++) {
        printf("Enter node %d name (single char): ", i + 1);
        scanf(" %c", &nodes[i].name);
        printf("Enter node %c heuristic cost: ", nodes[i].name);
        scanf("%d", &nodes[i].heuristic);
        nodes[i].cost = 0;
        nodes[i].numGroups = 0;
        nodes[i].bestPathSize = 0;
    }

    for (int i = 0; i < nodeCount; i++) {
        printf("Enter number of children groups for node %c (0 if leaf): ", nodes[i].name);
        scanf("%d", &nodes[i].numGroups);
        for (int g = 0; g < nodes[i].numGroups; g++) {
            printf("  Enter number of children in group %d: ", g + 1);
            scanf("%d", &nodes[i].groupSizes[g]);
            for (int c = 0; c < nodes[i].groupSizes[g]; c++) {
                char childName;
                printf("    Enter child %d name: ", c + 1);
                scanf(" %c", &childName);
                int childIndex = findNodeIndex(childName);
                if (childIndex == -1) {
                    printf("Error: Node %c not found. Exiting.\n", childName);
                    return 1;
                }
                nodes[i].children[g][c] = &nodes[childIndex];
            }
        }
    }

    int solvedCost[MAX_NODES] = {0};
    bool solved[MAX_NODES] = {false};

    ao(&nodes[0], solvedCost, solved);  
    printf("\nAO* Search Solution:\n");
    printSolution(&nodes[0], solvedCost, 0);

    return 0;
}
